// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 2.4.0,
// (C) 2004-2014 Robert Grimm,
// on Tuesday, September 25, 2018 at 2:48:28 PM.
// Edit at your own risk.
// ===========================================================================

package syntax;

import java.io.Reader;
import java.io.IOException;

import java.util.HashSet;
import java.util.Set;

import xtc.util.Pair;

import xtc.tree.Locatable;
import xtc.tree.Printer;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

import syntax.ExpParserSyntax.*;

import sbtrats.Action;
import xtc.tree.Location;

/**
 * Packrat parser for grammar <code>syntax.ExpParser</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 2.4.0, (C) 2004-2014 Robert Grimm.
 */
public final class ExpParser extends ParserBase {

  /** Flag for whether to emit tracing information while parsing. */
  public static final boolean DEBUG = true;

  /** Flag for whether to emit a peek into the input. */
  public static final boolean PEEK = true;

  /** The KEYWORDS set. */
  public static final Set<String> KEYWORDS = new HashSet<String>();

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result fSymbol;
    Result fNumFormula;
    Result fNumArguments;
    Result fCellRef;
    Result fCell;
    Result fmiddleOfString;
    Result fNumFormulaLevel2;
    Result fNumFormulaLevel2$$Star1;
    Result fNumFormulaLevel1;
    Result fNumFormulaLevel1$$Star1;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result fNumFormulaLevel0;
    Result fNumFormulaLevel0$$Plus1;
    Result fNumFormulaLevel0$$Plus2;
    Result f$$Shared1;
    Result fNumFormulaLevel0$$Plus4;
    Result fNumFormulaLevel0$$Plus6;
    Result fNumFormulaLevel0$$Plus7;
    Result fNumFormulaLevel0$$Plus8;
    Result fNumFormulaLevel0$$Plus9;
    Result fNumFormulaLevel0$$Plus10;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class ExpParserColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
  }

  // =========================================================================

  /** The printer for tracing this parser. */
  protected final Printer yyOut;

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public ExpParser(final Reader reader, final String file) {
    super(reader, file);
    yyOut = new Printer(System.out);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public ExpParser(final Reader reader, final String file, final int size) {
    super(reader, file, size);
    yyOut = new Printer(System.out);
  }

  // =========================================================================

  protected Column newColumn() {
    return new ExpParserColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.Symbol.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbol(final int yyStart) throws IOException {
    ExpParserColumn yyColumn = (ExpParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fSymbol) 
      yyColumn.chunk1.fSymbol = pSymbol$1(yyStart);
    traceLookup("Symbol", yyStart, yyColumn.chunk1.fSymbol);
    return yyColumn.chunk1.fSymbol;
  }

  /** Actually parse syntax.ExpParser.Symbol. */
  private Result pSymbol$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("Symbol", yyStart);

    // Alternative 1.

    yyResult = pSymbolCharacters(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        traceSuccess("Symbol", yyStart);
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    traceFailure("Symbol", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.SymbolCharacters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbolCharacters(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("SymbolCharacters", yyStart);

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'A':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('V' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('E' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('R' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('A' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('G' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('E' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('(' == yyC) {

                                      yyValue = "AVERAGE(";

                                      traceSuccess("SymbolCharacters", yyStart);
                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'S':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('U' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('M' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('(' == yyC) {

                      yyValue = "SUM(";

                      traceSuccess("SymbolCharacters", yyStart);
                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'I':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('F' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('(' == yyC) {

                  yyValue = "IF(";

                  traceSuccess("SymbolCharacters", yyStart);
                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }
          }
        }
        break;

      case '<':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = "<=";

              traceSuccess("SymbolCharacters", yyStart);
              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "<";

          traceSuccess("SymbolCharacters", yyStart);
          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '>':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = ">=";

              traceSuccess("SymbolCharacters", yyStart);
              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = ">";

          traceSuccess("SymbolCharacters", yyStart);
          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '\'':
        {
          yyValue = "\'";

          traceSuccess("SymbolCharacters", yyStart);
          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '[':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('.' == yyC) {

              yyValue = "[.";

              traceSuccess("SymbolCharacters", yyStart);
              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '*':
        {
          yyValue = "*";

          traceSuccess("SymbolCharacters", yyStart);
          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ']':
        {
          yyValue = "]";

          traceSuccess("SymbolCharacters", yyStart);
          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '=':
        {
          yyValue = "=";

          traceSuccess("SymbolCharacters", yyStart);
          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '&':
        {
          yyValue = "&";

          traceSuccess("SymbolCharacters", yyStart);
          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ')':
        {
          yyValue = ")";

          traceSuccess("SymbolCharacters", yyStart);
          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '-':
        {
          yyValue = "-";

          traceSuccess("SymbolCharacters", yyStart);
          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ',':
        {
          yyValue = ",";

          traceSuccess("SymbolCharacters", yyStart);
          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ';':
        {
          yyValue = ";";

          traceSuccess("SymbolCharacters", yyStart);
          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '+':
        {
          yyValue = "+";

          traceSuccess("SymbolCharacters", yyStart);
          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '(':
        {
          yyValue = "(";

          traceSuccess("SymbolCharacters", yyStart);
          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ':':
        {
          yyValue = ":";

          traceSuccess("SymbolCharacters", yyStart);
          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '^':
        {
          yyValue = "^";

          traceSuccess("SymbolCharacters", yyStart);
          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '/':
        {
          yyValue = "/";

          traceSuccess("SymbolCharacters", yyStart);
          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    traceFailure("SymbolCharacters", yyStart);
    yyError = yyError.select("symbol characters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.Program.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pProgram(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Exp>  yyRepValue1;
    Program    yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("Program", yyStart);

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pExp(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {
        Exp v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new Pair<Exp>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for v1.
      Pair<Exp> v1 = yyRepValue1.reverse();

      yyValue = new Program (v1);

      if (yyValue instanceof Locatable) {
        setLocation((Locatable)yyValue, yyStart);
      }
      traceSuccess("Program", yyStart);
      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for v1.
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.Exp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pExp(final int yyStart) throws IOException {
    Result     yyResult;
    Exp        yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("Exp", yyStart);

    // Alternative 1.

    yyResult = pAssign(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Exp v1 = yyResult.semanticValue();

      yyValue = v1;

      traceSuccess("Exp", yyStart);
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    traceFailure("Exp", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.Assign.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAssign(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Exp        yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("Assign", yyStart);

    // Alternative 1.

    yyResult = pCell(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NumFormula v1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("=")) {

        yyResult = pFormula(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Formula v2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyValue = new Assign (v1, v2);

            if (yyValue instanceof Locatable) {
              setLocation((Locatable)yyValue, yyStart);
            }
            traceSuccess("Assign", yyStart);
            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'=' expected", yyBase);
      }
    }

    // Done.
    traceFailure("Assign", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.Formula.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pFormula(final int yyStart) throws IOException {
    Result     yyResult;
    Formula    yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("Formula", yyStart);

    // Alternative 1.

    yyResult = pNumFormula(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NumFormula v1 = yyResult.semanticValue();

      yyValue = new nf (v1);

      if (yyValue instanceof Locatable) {
        setLocation((Locatable)yyValue, yyStart);
      }
      traceSuccess("Formula", yyStart);
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pStringFormula(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      StringFormula v1 = yyResult.semanticValue();

      yyValue = new sf (v1);

      if (yyValue instanceof Locatable) {
        setLocation((Locatable)yyValue, yyStart);
      }
      traceSuccess("Formula", yyStart);
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    traceFailure("Formula", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.NumFormula.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pNumFormula(final int yyStart) throws IOException {
    ExpParserColumn yyColumn = (ExpParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fNumFormula) 
      yyColumn.chunk1.fNumFormula = pNumFormula$1(yyStart);
    traceLookup("NumFormula", yyStart, yyColumn.chunk1.fNumFormula);
    return yyColumn.chunk1.fNumFormula;
  }

  /** Actually parse syntax.ExpParser.NumFormula. */
  private Result pNumFormula$1(final int yyStart) throws IOException {
    Result     yyResult;
    NumFormula yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("NumFormula", yyStart);

    // Alternative 1.

    yyResult = pNumFormulaLevel3(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NumFormula v1 = yyResult.semanticValue();

      yyValue = v1;

      traceSuccess("NumFormula", yyStart);
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    traceFailure("NumFormula", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.StringFormula.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pStringFormula(final int yyStart) throws IOException {
    Result        yyResult;
    StringFormula yyValue;
    ParseError    yyError = ParseError.DUMMY;

    traceEnter("StringFormula", yyStart);

    // Alternative 1.

    yyResult = pStr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v1 = yyResult.semanticValue();

      yyValue = new strConst (v1);

      if (yyValue instanceof Locatable) {
        setLocation((Locatable)yyValue, yyStart);
      }
      traceSuccess("StringFormula", yyStart);
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNumFormula(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NumFormula v1 = yyResult.semanticValue();

      yyValue = new NumAsStr (v1);

      if (yyValue instanceof Locatable) {
        setLocation((Locatable)yyValue, yyStart);
      }
      traceSuccess("StringFormula", yyStart);
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    traceFailure("StringFormula", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.NumArguments.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pNumArguments(final int yyStart) throws IOException {
    ExpParserColumn yyColumn = (ExpParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fNumArguments) 
      yyColumn.chunk1.fNumArguments = pNumArguments$1(yyStart);
    traceLookup("NumArguments", yyStart, yyColumn.chunk1.fNumArguments);
    return yyColumn.chunk1.fNumArguments;
  }

  /** Actually parse syntax.ExpParser.NumArguments. */
  private Result pNumArguments$1(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyBase;
    NumArguments yyValue;
    ParseError   yyError = ParseError.DUMMY;

    traceEnter("NumArguments", yyStart);

    // Alternative 1.

    yyResult = pNumFormula(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NumFormula v1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(";")) {

        yyResult = pNumArguments(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          NumArguments v2 = yyResult.semanticValue();

          yyValue = new Args (v1, v2);

          if (yyValue instanceof Locatable) {
            setLocation((Locatable)yyValue, yyStart);
          }
          traceSuccess("NumArguments", yyStart);
          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }

      // Nested alternative 2.

      yyValue = new Arg (v1);

      if (yyValue instanceof Locatable) {
        setLocation((Locatable)yyValue, yyStart);
      }
      traceSuccess("NumArguments", yyStart);
      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    traceFailure("NumArguments", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.NumConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pNumConstant(final int yyStart) throws IOException {
    Result     yyResult;
    NumFormula yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("NumConstant", yyStart);

    // Alternative 1.

    yyResult = pInteger(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v1 = yyResult.semanticValue();

      yyValue = new Num (v1);

      if (yyValue instanceof Locatable) {
        setLocation((Locatable)yyValue, yyStart);
      }
      traceSuccess("NumConstant", yyStart);
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pBool(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v1 = yyResult.semanticValue();

      yyValue = new Boo (v1);

      if (yyValue instanceof Locatable) {
        setLocation((Locatable)yyValue, yyStart);
      }
      traceSuccess("NumConstant", yyStart);
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    traceFailure("NumConstant", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.Array.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pArray(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    NumFormula yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("Array", yyStart);

    // Alternative 1.

    yyResult = pCellRef(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NumFormula v1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(":")) {

        yyResult = pCellRef(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          NumFormula v2 = yyResult.semanticValue();

          yyValue = new Arr (v1, v2);

          if (yyValue instanceof Locatable) {
            setLocation((Locatable)yyValue, yyStart);
          }
          traceSuccess("Array", yyStart);
          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }
    }

    // Done.
    traceFailure("Array", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.CellRef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pCellRef(final int yyStart) throws IOException {
    ExpParserColumn yyColumn = (ExpParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fCellRef) 
      yyColumn.chunk1.fCellRef = pCellRef$1(yyStart);
    traceLookup("CellRef", yyStart, yyColumn.chunk1.fCellRef);
    return yyColumn.chunk1.fCellRef;
  }

  /** Actually parse syntax.ExpParser.CellRef. */
  private Result pCellRef$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    NumFormula yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("CellRef", yyStart);

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("[.")) {

      yyResult = pCell(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        NumFormula v1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("]")) {

          yyValue = new Ref (v1);

          if (yyValue instanceof Locatable) {
            setLocation((Locatable)yyValue, yyStart);
          }
          traceSuccess("CellRef", yyStart);
          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }
      }
    }

    // Done.
    traceFailure("CellRef", yyStart);
    yyError = yyError.select("cell ref expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.Cell.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pCell(final int yyStart) throws IOException {
    ExpParserColumn yyColumn = (ExpParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fCell) 
      yyColumn.chunk1.fCell = pCell$1(yyStart);
    traceLookup("Cell", yyStart, yyColumn.chunk1.fCell);
    return yyColumn.chunk1.fCell;
  }

  /** Actually parse syntax.ExpParser.Cell. */
  private Result pCell$1(final int yyStart) throws IOException {
    Result     yyResult;
    NumFormula yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("Cell", yyStart);

    // Alternative 1.

    yyResult = pcol(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v1 = yyResult.semanticValue();

      yyResult = prow(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v2 = yyResult.semanticValue();

        yyValue = new Cell (v1, v2);

        if (yyValue instanceof Locatable) {
          setLocation((Locatable)yyValue, yyStart);
        }
        traceSuccess("Cell", yyStart);
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    traceFailure("Cell", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.col.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pcol(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("col", yyStart);

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;
        if (('A' <= yyC) && (yyC <= 'Z')) {

          yyRepetition1 = yyIndex;
          yyRepeated1   = true;
          continue;
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = difference(yyStart, yyRepetition1);

      traceSuccess("col", yyStart);
      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    traceFailure("col", yyStart);
    yyError = yyError.select("col expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.row.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result prow(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("row", yyStart);

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyRepetition1 = yyIndex;
          while (true) {

            yyC = character(yyRepetition1);
            if (-1 != yyC) {
              yyIndex = yyRepetition1 + 1;

              switch (yyC) {
              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
              case '8':
              case '9':
                {
                  yyRepetition1 = yyIndex;
                  continue;
                }

              default:
                /* No match. */
              }
            }
            break;
          }

          yyValue = difference(yyStart, yyRepetition1);

          traceSuccess("row", yyStart);
          return new SemanticValue(yyValue, yyRepetition1, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    traceFailure("row", yyStart);
    yyError = yyError.select("row expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.Integer.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pInteger(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("Integer", yyStart);

    // Alternative 1.

    yyResult = pDigits(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        traceSuccess("Integer", yyStart);
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    traceFailure("Integer", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.Digits.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pDigits(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("Digits", yyStart);

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = difference(yyStart, yyRepetition1);

      traceSuccess("Digits", yyStart);
      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    traceFailure("Digits", yyStart);
    yyError = yyError.select("digits expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.Str.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pStr(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("Str", yyStart);

    // Alternative 1.

    yyC = character(yyStart);
    if ('\'' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      yyRepeated1   = false;
      while (true) {

        yyResult = pmiddleOfString(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          continue;
        }
        break;
      }

      if (yyRepeated1) {

        yyValue = difference(yyStart, yyRepetition1);

        traceSuccess("Str", yyStart);
        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    traceFailure("Str", yyStart);
    yyError = yyError.select("str expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.middleOfString.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pmiddleOfString(final int yyStart) throws IOException {
    ExpParserColumn yyColumn = (ExpParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fmiddleOfString) 
      yyColumn.chunk1.fmiddleOfString = pmiddleOfString$1(yyStart);
    traceLookup("middleOfString", yyStart, yyColumn.chunk1.fmiddleOfString);
    return yyColumn.chunk1.fmiddleOfString;
  }

  /** Actually parse syntax.ExpParser.middleOfString. */
  private Result pmiddleOfString$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("middleOfString", yyStart);

    // Alternative 1.

    yyC = character(yyStart);
    if ('\'' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = "\'";

      traceSuccess("middleOfString", yyStart);
      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      yyResult = pmiddleOfString(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = difference(yyStart, yyResult.index);

        traceSuccess("middleOfString", yyStart);
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    traceFailure("middleOfString", yyStart);
    yyError = yyError.select("middle of string expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.Digit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pDigit(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("Digit", yyStart);

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyValue = difference(yyStart, yyIndex);

          traceSuccess("Digit", yyStart);
          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    traceFailure("Digit", yyStart);
    yyError = yyError.select("digit expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.Letters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pLetters(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("Letters", yyStart);

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;
        if (('A' <= yyC) && (yyC <= 'Z')) {

          yyRepetition1 = yyIndex;
          yyRepeated1   = true;
          continue;
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = difference(yyStart, yyRepetition1);

      traceSuccess("Letters", yyStart);
      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    traceFailure("Letters", yyStart);
    yyError = yyError.select("letters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.Letter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pLetter(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("Letter", yyStart);

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if (('A' <= yyC) && (yyC <= 'Z')) {

        yyValue = difference(yyStart, yyIndex);

        traceSuccess("Letter", yyStart);
        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    traceFailure("Letter", yyStart);
    yyError = yyError.select("letter expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.Bool.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pBool(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("Bool", yyStart);

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'f':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('a' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('l' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('s' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('e' == yyC) {

                          yyValue = "false";

                          traceSuccess("Bool", yyStart);
                          return new SemanticValue(yyValue, yyIndex, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 't':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('r' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('u' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('e' == yyC) {

                      yyValue = "true";

                      traceSuccess("Bool", yyStart);
                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    traceFailure("Bool", yyStart);
    yyError = yyError.select("bool expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.NumFormulaLevel2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pNumFormulaLevel2(final int yyStart) throws IOException {
    ExpParserColumn yyColumn = (ExpParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fNumFormulaLevel2) 
      yyColumn.chunk1.fNumFormulaLevel2 = pNumFormulaLevel2$1(yyStart);
    traceLookup("NumFormulaLevel2", yyStart, 
      yyColumn.chunk1.fNumFormulaLevel2);
    return yyColumn.chunk1.fNumFormulaLevel2;
  }

  /** Actually parse syntax.ExpParser.NumFormulaLevel2. */
  private Result pNumFormulaLevel2$1(final int yyStart) throws IOException {
    Result     yyResult;
    NumFormula yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("NumFormulaLevel2", yyStart);

    // Alternative 1.

    yyResult = pNumFormulaLevel1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NumFormula v1 = yyResult.semanticValue();

      yyResult = pNumFormulaLevel2$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<NumFormula>> v2 = yyResult.semanticValue();

        yyValue = ParserSupport.apply(v2, v1);

        if (yyValue instanceof Locatable) {
          setLocation((Locatable)yyValue, yyStart);
        }
        traceSuccess("NumFormulaLevel2", yyStart);
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    traceFailure("NumFormulaLevel2", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal syntax.ExpParser.NumFormulaLevel2$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumFormulaLevel2$$Star1(final int yyStart) 
    throws IOException {

    ExpParserColumn yyColumn = (ExpParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fNumFormulaLevel2$$Star1) 
      yyColumn.chunk1.fNumFormulaLevel2$$Star1 = pNumFormulaLevel2$$Star1$1(yyStart);
    traceLookup("NumFormulaLevel2$$Star1", yyStart, 
      yyColumn.chunk1.fNumFormulaLevel2$$Star1);
    return yyColumn.chunk1.fNumFormulaLevel2$$Star1;
  }

  /** Actually parse syntax.ExpParser.NumFormulaLevel2$$Star1. */
  private Result pNumFormulaLevel2$$Star1$1(final int yyStart) 
    throws IOException {

    Result                   yyResult;
    Pair<Action<NumFormula>> yyValue;
    ParseError               yyError = ParseError.DUMMY;

    traceEnter("NumFormulaLevel2$$Star1", yyStart);

    // Alternative 1.

    yyResult = pNumFormulaLevel2Tail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<NumFormula> v$el$1 = yyResult.semanticValue();

      yyResult = pNumFormulaLevel2$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<NumFormula>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<NumFormula>>(v$el$1, v$2);

        traceSuccess("NumFormulaLevel2$$Star1", yyStart);
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    traceSuccess("NumFormulaLevel2$$Star1", yyStart);
    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.NumFormulaLevel2Tail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumFormulaLevel2Tail(final int yyStart) throws IOException {
    Result             yyResult;
    Action<NumFormula> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    traceEnter("NumFormulaLevel2Tail", yyStart);

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("+")) {

      yyResult = pNumFormulaLevel1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final NumFormula v1 = yyResult.semanticValue();

        yyValue = new Action<NumFormula>() {
          public NumFormula run (NumFormula left) {
            Add node = new Add (left, v1);
            copyLocation(node, left);
            return node;
          };
        };

        traceSuccess("NumFormulaLevel2Tail", yyStart);
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("-")) {

      yyResult = pNumFormulaLevel1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final NumFormula v1 = yyResult.semanticValue();

        yyValue = new Action<NumFormula>() {
          public NumFormula run (NumFormula left) {
            Sub node = new Sub (left, v1);
            copyLocation(node, left);
            return node;
          };
        };

        traceSuccess("NumFormulaLevel2Tail", yyStart);
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    traceFailure("NumFormulaLevel2Tail", yyStart);
    yyError = yyError.select("num formula level2 tail expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.NumFormulaLevel1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pNumFormulaLevel1(final int yyStart) throws IOException {
    ExpParserColumn yyColumn = (ExpParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fNumFormulaLevel1) 
      yyColumn.chunk1.fNumFormulaLevel1 = pNumFormulaLevel1$1(yyStart);
    traceLookup("NumFormulaLevel1", yyStart, 
      yyColumn.chunk1.fNumFormulaLevel1);
    return yyColumn.chunk1.fNumFormulaLevel1;
  }

  /** Actually parse syntax.ExpParser.NumFormulaLevel1. */
  private Result pNumFormulaLevel1$1(final int yyStart) throws IOException {
    Result     yyResult;
    NumFormula yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("NumFormulaLevel1", yyStart);

    // Alternative 1.

    yyResult = pNumFormulaLevel0(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NumFormula v1 = yyResult.semanticValue();

      yyResult = pNumFormulaLevel1$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<NumFormula>> v2 = yyResult.semanticValue();

        yyValue = ParserSupport.apply(v2, v1);

        if (yyValue instanceof Locatable) {
          setLocation((Locatable)yyValue, yyStart);
        }
        traceSuccess("NumFormulaLevel1", yyStart);
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    traceFailure("NumFormulaLevel1", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal syntax.ExpParser.NumFormulaLevel1$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumFormulaLevel1$$Star1(final int yyStart) 
    throws IOException {

    ExpParserColumn yyColumn = (ExpParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fNumFormulaLevel1$$Star1) 
      yyColumn.chunk1.fNumFormulaLevel1$$Star1 = pNumFormulaLevel1$$Star1$1(yyStart);
    traceLookup("NumFormulaLevel1$$Star1", yyStart, 
      yyColumn.chunk1.fNumFormulaLevel1$$Star1);
    return yyColumn.chunk1.fNumFormulaLevel1$$Star1;
  }

  /** Actually parse syntax.ExpParser.NumFormulaLevel1$$Star1. */
  private Result pNumFormulaLevel1$$Star1$1(final int yyStart) 
    throws IOException {

    Result                   yyResult;
    Pair<Action<NumFormula>> yyValue;
    ParseError               yyError = ParseError.DUMMY;

    traceEnter("NumFormulaLevel1$$Star1", yyStart);

    // Alternative 1.

    yyResult = pNumFormulaLevel1Tail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<NumFormula> v$el$1 = yyResult.semanticValue();

      yyResult = pNumFormulaLevel1$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<NumFormula>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<NumFormula>>(v$el$1, v$2);

        traceSuccess("NumFormulaLevel1$$Star1", yyStart);
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    traceSuccess("NumFormulaLevel1$$Star1", yyStart);
    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.NumFormulaLevel1Tail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumFormulaLevel1Tail(final int yyStart) throws IOException {
    Result             yyResult;
    Action<NumFormula> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    traceEnter("NumFormulaLevel1Tail", yyStart);

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("*")) {

      yyResult = pNumFormulaLevel0(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final NumFormula v1 = yyResult.semanticValue();

        yyValue = new Action<NumFormula>() {
          public NumFormula run (NumFormula left) {
            Mul node = new Mul (left, v1);
            copyLocation(node, left);
            return node;
          };
        };

        traceSuccess("NumFormulaLevel1Tail", yyStart);
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("/")) {

      yyResult = pNumFormulaLevel0(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final NumFormula v1 = yyResult.semanticValue();

        yyValue = new Action<NumFormula>() {
          public NumFormula run (NumFormula left) {
            Div node = new Div (left, v1);
            copyLocation(node, left);
            return node;
          };
        };

        traceSuccess("NumFormulaLevel1Tail", yyStart);
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    traceFailure("NumFormulaLevel1Tail", yyStart);
    yyError = yyError.select("num formula level1 tail expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.NumFormulaLevel3.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pNumFormulaLevel3(final int yyStart) throws IOException {
    Result                   yyResult;
    int                      yyRepetition1;
    Pair<Action<NumFormula>> yyRepValue1;
    NumFormula               yyValue;
    ParseError               yyError = ParseError.DUMMY;

    traceEnter("NumFormulaLevel3", yyStart);

    // Alternative 1.

    yyResult = pNumFormulaLevel2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NumFormula v1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pNumFormulaLevel3Tail(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          Action<NumFormula> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<NumFormula>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v2.
        Pair<Action<NumFormula>> v2 = yyRepValue1.reverse();

        yyValue = ParserSupport.apply(v2, v1);

        if (yyValue instanceof Locatable) {
          setLocation((Locatable)yyValue, yyStart);
        }
        traceSuccess("NumFormulaLevel3", yyStart);
        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v2.
    }

    // Done.
    traceFailure("NumFormulaLevel3", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.NumFormulaLevel3Tail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumFormulaLevel3Tail(final int yyStart) throws IOException {
    Result             yyResult;
    Action<NumFormula> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    traceEnter("NumFormulaLevel3Tail", yyStart);

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("^")) {

      yyResult = pNumFormulaLevel2(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final NumFormula v1 = yyResult.semanticValue();

        yyValue = new Action<NumFormula>() {
          public NumFormula run (NumFormula left) {
            pow node = new pow (left, v1);
            copyLocation(node, left);
            return node;
          };
        };

        traceSuccess("NumFormulaLevel3Tail", yyStart);
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("&")) {

      yyResult = pNumFormulaLevel2(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final NumFormula v1 = yyResult.semanticValue();

        yyValue = new Action<NumFormula>() {
          public NumFormula run (NumFormula left) {
            and node = new and (left, v1);
            copyLocation(node, left);
            return node;
          };
        };

        traceSuccess("NumFormulaLevel3Tail", yyStart);
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("<")) {

      yyResult = pNumFormulaLevel2(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final NumFormula v1 = yyResult.semanticValue();

        yyValue = new Action<NumFormula>() {
          public NumFormula run (NumFormula left) {
            less node = new less (left, v1);
            copyLocation(node, left);
            return node;
          };
        };

        traceSuccess("NumFormulaLevel3Tail", yyStart);
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(">")) {

      yyResult = pNumFormulaLevel2(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final NumFormula v1 = yyResult.semanticValue();

        yyValue = new Action<NumFormula>() {
          public NumFormula run (NumFormula left) {
            great node = new great (left, v1);
            copyLocation(node, left);
            return node;
          };
        };

        traceSuccess("NumFormulaLevel3Tail", yyStart);
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 5.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("=")) {

      yyResult = pNumFormulaLevel2(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final NumFormula v1 = yyResult.semanticValue();

        yyValue = new Action<NumFormula>() {
          public NumFormula run (NumFormula left) {
            equal node = new equal (left, v1);
            copyLocation(node, left);
            return node;
          };
        };

        traceSuccess("NumFormulaLevel3Tail", yyStart);
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 6.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("<=")) {

      yyResult = pNumFormulaLevel2(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final NumFormula v1 = yyResult.semanticValue();

        yyValue = new Action<NumFormula>() {
          public NumFormula run (NumFormula left) {
            lessEqual node = new lessEqual (left, v1);
            copyLocation(node, left);
            return node;
          };
        };

        traceSuccess("NumFormulaLevel3Tail", yyStart);
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 7.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(">=")) {

      yyResult = pNumFormulaLevel2(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final NumFormula v1 = yyResult.semanticValue();

        yyValue = new Action<NumFormula>() {
          public NumFormula run (NumFormula left) {
            greatEqual node = new greatEqual (left, v1);
            copyLocation(node, left);
            return node;
          };
        };

        traceSuccess("NumFormulaLevel3Tail", yyStart);
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    traceFailure("NumFormulaLevel3Tail", yyStart);
    yyError = yyError.select("num formula level3 tail expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.NumFormulaLevel0.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pNumFormulaLevel0(final int yyStart) throws IOException {
    ExpParserColumn yyColumn = (ExpParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fNumFormulaLevel0) 
      yyColumn.chunk2.fNumFormulaLevel0 = pNumFormulaLevel0$1(yyStart);
    traceLookup("NumFormulaLevel0", yyStart, 
      yyColumn.chunk2.fNumFormulaLevel0);
    return yyColumn.chunk2.fNumFormulaLevel0;
  }

  /** Actually parse syntax.ExpParser.NumFormulaLevel0. */
  private Result pNumFormulaLevel0$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    NumFormula yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("NumFormulaLevel0", yyStart);

    // Alternative 1.

    yyResult = pNumFormulaLevel0$$Plus1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pNumFormulaLevel0$$Plus2(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<NumFormula> v1 = yyResult.semanticValue();

        yyResult = p$$Shared1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pNumFormulaLevel0$$Plus4(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Pair<NumFormula> v2 = yyResult.semanticValue();

            yyResult = p$$Shared1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pNumFormulaLevel0$$Plus6(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Pair<NumFormula> v3 = yyResult.semanticValue();

                yyBase   = yyResult.index;
                yyResult = pSymbol(yyBase);
                if (yyResult.hasValue(")")) {

                  yyValue = new numIF (v1, v2, v3);

                  if (yyValue instanceof Locatable) {
                    setLocation((Locatable)yyValue, yyStart);
                  }
                  traceSuccess("NumFormulaLevel0", yyStart);
                  return yyResult.createValue(yyValue, yyError);
                } else {
                  yyError = yyError.select("')' expected", yyBase);
                }
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pNumFormulaLevel0$$Plus7(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pNumFormulaLevel0$$Plus8(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<NumArguments> v1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          yyValue = new SUM (v1);

          if (yyValue instanceof Locatable) {
            setLocation((Locatable)yyValue, yyStart);
          }
          traceSuccess("NumFormulaLevel0", yyStart);
          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Alternative 3.

    yyResult = pNumFormulaLevel0$$Plus9(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pNumFormulaLevel0$$Plus10(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<NumArguments> v1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          yyValue = new AVERAGE (v1);

          if (yyValue instanceof Locatable) {
            setLocation((Locatable)yyValue, yyStart);
          }
          traceSuccess("NumFormulaLevel0", yyStart);
          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Alternative 4.

    yyResult = pArray(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NumFormula v1 = yyResult.semanticValue();

      yyValue = v1;

      traceSuccess("NumFormulaLevel0", yyStart);
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pCellRef(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NumFormula v1 = yyResult.semanticValue();

      yyValue = v1;

      traceSuccess("NumFormulaLevel0", yyStart);
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pNumConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NumFormula v1 = yyResult.semanticValue();

      yyValue = v1;

      traceSuccess("NumFormulaLevel0", yyStart);
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pNumFormula(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        NumFormula v1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          yyValue = v1;

          traceSuccess("NumFormulaLevel0", yyStart);
          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Done.
    traceFailure("NumFormulaLevel0", yyStart);
    yyError = yyError.select("num formula level0 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal syntax.ExpParser.NumFormulaLevel0$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumFormulaLevel0$$Plus1(final int yyStart) 
    throws IOException {

    ExpParserColumn yyColumn = (ExpParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fNumFormulaLevel0$$Plus1) 
      yyColumn.chunk2.fNumFormulaLevel0$$Plus1 = pNumFormulaLevel0$$Plus1$1(yyStart);
    traceLookup("NumFormulaLevel0$$Plus1", yyStart, 
      yyColumn.chunk2.fNumFormulaLevel0$$Plus1);
    return yyColumn.chunk2.fNumFormulaLevel0$$Plus1;
  }

  /** Actually parse syntax.ExpParser.NumFormulaLevel0$$Plus1. */
  private Result pNumFormulaLevel0$$Plus1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("NumFormulaLevel0$$Plus1", yyStart);

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("IF(")) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNumFormulaLevel0$$Plus1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        traceSuccess("NumFormulaLevel0$$Plus1", yyStart);
        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = null;

      traceSuccess("NumFormulaLevel0$$Plus1", yyStart);
      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    traceFailure("NumFormulaLevel0$$Plus1", yyStart);
    yyError = yyError.select("num formula level0 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal syntax.ExpParser.NumFormulaLevel0$$Plus2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumFormulaLevel0$$Plus2(final int yyStart) 
    throws IOException {

    ExpParserColumn yyColumn = (ExpParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fNumFormulaLevel0$$Plus2) 
      yyColumn.chunk2.fNumFormulaLevel0$$Plus2 = pNumFormulaLevel0$$Plus2$1(yyStart);
    traceLookup("NumFormulaLevel0$$Plus2", yyStart, 
      yyColumn.chunk2.fNumFormulaLevel0$$Plus2);
    return yyColumn.chunk2.fNumFormulaLevel0$$Plus2;
  }

  /** Actually parse syntax.ExpParser.NumFormulaLevel0$$Plus2. */
  private Result pNumFormulaLevel0$$Plus2$1(final int yyStart) 
    throws IOException {

    Result           yyResult;
    Pair<NumFormula> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    traceEnter("NumFormulaLevel0$$Plus2", yyStart);

    // Alternative 1.

    yyResult = pNumFormula(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NumFormula v$el$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNumFormulaLevel0$$Plus2(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<NumFormula> v$2 = yyResult.semanticValue();

        yyValue = new Pair<NumFormula>(v$el$1, v$2);

        traceSuccess("NumFormulaLevel0$$Plus2", yyStart);
        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = new Pair<NumFormula>(v$el$1);

      traceSuccess("NumFormulaLevel0$$Plus2", yyStart);
      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    traceFailure("NumFormulaLevel0$$Plus2", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal syntax.ExpParser.$$Shared1.
   * This nonterminal represents the duplicate productions 
   * syntax.ExpParser.NumFormulaLevel0$$Plus3 
   * and syntax.ExpParser.NumFormulaLevel0$$Plus5.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared1(final int yyStart) throws IOException {
    ExpParserColumn yyColumn = (ExpParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.f$$Shared1) 
      yyColumn.chunk2.f$$Shared1 = p$$Shared1$1(yyStart);
    traceLookup("$$Shared1", yyStart, yyColumn.chunk2.f$$Shared1);
    return yyColumn.chunk2.f$$Shared1;
  }

  /** Actually parse syntax.ExpParser.$$Shared1. */
  private Result p$$Shared1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("$$Shared1", yyStart);

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(";")) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = p$$Shared1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        traceSuccess("$$Shared1", yyStart);
        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = null;

      traceSuccess("$$Shared1", yyStart);
      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    traceFailure("$$Shared1", yyStart);
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal syntax.ExpParser.NumFormulaLevel0$$Plus4.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumFormulaLevel0$$Plus4(final int yyStart) 
    throws IOException {

    ExpParserColumn yyColumn = (ExpParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fNumFormulaLevel0$$Plus4) 
      yyColumn.chunk2.fNumFormulaLevel0$$Plus4 = pNumFormulaLevel0$$Plus4$1(yyStart);
    traceLookup("NumFormulaLevel0$$Plus4", yyStart, 
      yyColumn.chunk2.fNumFormulaLevel0$$Plus4);
    return yyColumn.chunk2.fNumFormulaLevel0$$Plus4;
  }

  /** Actually parse syntax.ExpParser.NumFormulaLevel0$$Plus4. */
  private Result pNumFormulaLevel0$$Plus4$1(final int yyStart) 
    throws IOException {

    Result           yyResult;
    Pair<NumFormula> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    traceEnter("NumFormulaLevel0$$Plus4", yyStart);

    // Alternative 1.

    yyResult = pNumFormula(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NumFormula v$el$3 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNumFormulaLevel0$$Plus4(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<NumFormula> v$4 = yyResult.semanticValue();

        yyValue = new Pair<NumFormula>(v$el$3, v$4);

        traceSuccess("NumFormulaLevel0$$Plus4", yyStart);
        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = new Pair<NumFormula>(v$el$3);

      traceSuccess("NumFormulaLevel0$$Plus4", yyStart);
      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    traceFailure("NumFormulaLevel0$$Plus4", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal syntax.ExpParser.NumFormulaLevel0$$Plus6.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumFormulaLevel0$$Plus6(final int yyStart) 
    throws IOException {

    ExpParserColumn yyColumn = (ExpParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fNumFormulaLevel0$$Plus6) 
      yyColumn.chunk2.fNumFormulaLevel0$$Plus6 = pNumFormulaLevel0$$Plus6$1(yyStart);
    traceLookup("NumFormulaLevel0$$Plus6", yyStart, 
      yyColumn.chunk2.fNumFormulaLevel0$$Plus6);
    return yyColumn.chunk2.fNumFormulaLevel0$$Plus6;
  }

  /** Actually parse syntax.ExpParser.NumFormulaLevel0$$Plus6. */
  private Result pNumFormulaLevel0$$Plus6$1(final int yyStart) 
    throws IOException {

    Result           yyResult;
    Pair<NumFormula> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    traceEnter("NumFormulaLevel0$$Plus6", yyStart);

    // Alternative 1.

    yyResult = pNumFormula(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NumFormula v$el$5 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNumFormulaLevel0$$Plus6(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<NumFormula> v$6 = yyResult.semanticValue();

        yyValue = new Pair<NumFormula>(v$el$5, v$6);

        traceSuccess("NumFormulaLevel0$$Plus6", yyStart);
        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = new Pair<NumFormula>(v$el$5);

      traceSuccess("NumFormulaLevel0$$Plus6", yyStart);
      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    traceFailure("NumFormulaLevel0$$Plus6", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal syntax.ExpParser.NumFormulaLevel0$$Plus7.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumFormulaLevel0$$Plus7(final int yyStart) 
    throws IOException {

    ExpParserColumn yyColumn = (ExpParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fNumFormulaLevel0$$Plus7) 
      yyColumn.chunk2.fNumFormulaLevel0$$Plus7 = pNumFormulaLevel0$$Plus7$1(yyStart);
    traceLookup("NumFormulaLevel0$$Plus7", yyStart, 
      yyColumn.chunk2.fNumFormulaLevel0$$Plus7);
    return yyColumn.chunk2.fNumFormulaLevel0$$Plus7;
  }

  /** Actually parse syntax.ExpParser.NumFormulaLevel0$$Plus7. */
  private Result pNumFormulaLevel0$$Plus7$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("NumFormulaLevel0$$Plus7", yyStart);

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("SUM(")) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNumFormulaLevel0$$Plus7(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        traceSuccess("NumFormulaLevel0$$Plus7", yyStart);
        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = null;

      traceSuccess("NumFormulaLevel0$$Plus7", yyStart);
      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    traceFailure("NumFormulaLevel0$$Plus7", yyStart);
    yyError = yyError.select("num formula level0 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal syntax.ExpParser.NumFormulaLevel0$$Plus8.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumFormulaLevel0$$Plus8(final int yyStart) 
    throws IOException {

    ExpParserColumn yyColumn = (ExpParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fNumFormulaLevel0$$Plus8) 
      yyColumn.chunk2.fNumFormulaLevel0$$Plus8 = pNumFormulaLevel0$$Plus8$1(yyStart);
    traceLookup("NumFormulaLevel0$$Plus8", yyStart, 
      yyColumn.chunk2.fNumFormulaLevel0$$Plus8);
    return yyColumn.chunk2.fNumFormulaLevel0$$Plus8;
  }

  /** Actually parse syntax.ExpParser.NumFormulaLevel0$$Plus8. */
  private Result pNumFormulaLevel0$$Plus8$1(final int yyStart) 
    throws IOException {

    Result             yyResult;
    Pair<NumArguments> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    traceEnter("NumFormulaLevel0$$Plus8", yyStart);

    // Alternative 1.

    yyResult = pNumArguments(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NumArguments v$el$7 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNumFormulaLevel0$$Plus8(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<NumArguments> v$8 = yyResult.semanticValue();

        yyValue = new Pair<NumArguments>(v$el$7, v$8);

        traceSuccess("NumFormulaLevel0$$Plus8", yyStart);
        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = new Pair<NumArguments>(v$el$7);

      traceSuccess("NumFormulaLevel0$$Plus8", yyStart);
      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    traceFailure("NumFormulaLevel0$$Plus8", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal syntax.ExpParser.NumFormulaLevel0$$Plus9.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumFormulaLevel0$$Plus9(final int yyStart) 
    throws IOException {

    ExpParserColumn yyColumn = (ExpParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fNumFormulaLevel0$$Plus9) 
      yyColumn.chunk2.fNumFormulaLevel0$$Plus9 = pNumFormulaLevel0$$Plus9$1(yyStart);
    traceLookup("NumFormulaLevel0$$Plus9", yyStart, 
      yyColumn.chunk2.fNumFormulaLevel0$$Plus9);
    return yyColumn.chunk2.fNumFormulaLevel0$$Plus9;
  }

  /** Actually parse syntax.ExpParser.NumFormulaLevel0$$Plus9. */
  private Result pNumFormulaLevel0$$Plus9$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("NumFormulaLevel0$$Plus9", yyStart);

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("AVERAGE(")) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNumFormulaLevel0$$Plus9(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        traceSuccess("NumFormulaLevel0$$Plus9", yyStart);
        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = null;

      traceSuccess("NumFormulaLevel0$$Plus9", yyStart);
      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    traceFailure("NumFormulaLevel0$$Plus9", yyStart);
    yyError = yyError.select("num formula level0 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal syntax.ExpParser.NumFormulaLevel0$$Plus10.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumFormulaLevel0$$Plus10(final int yyStart) 
    throws IOException {

    ExpParserColumn yyColumn = (ExpParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fNumFormulaLevel0$$Plus10) 
      yyColumn.chunk2.fNumFormulaLevel0$$Plus10 = pNumFormulaLevel0$$Plus10$1(yyStart);
    traceLookup("NumFormulaLevel0$$Plus10", yyStart, 
      yyColumn.chunk2.fNumFormulaLevel0$$Plus10);
    return yyColumn.chunk2.fNumFormulaLevel0$$Plus10;
  }

  /** Actually parse syntax.ExpParser.NumFormulaLevel0$$Plus10. */
  private Result pNumFormulaLevel0$$Plus10$1(final int yyStart) 
    throws IOException {

    Result             yyResult;
    Pair<NumArguments> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    traceEnter("NumFormulaLevel0$$Plus10", yyStart);

    // Alternative 1.

    yyResult = pNumArguments(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NumArguments v$el$9 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNumFormulaLevel0$$Plus10(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<NumArguments> v$10 = yyResult.semanticValue();

        yyValue = new Pair<NumArguments>(v$el$9, v$10);

        traceSuccess("NumFormulaLevel0$$Plus10", yyStart);
        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = new Pair<NumArguments>(v$el$9);

      traceSuccess("NumFormulaLevel0$$Plus10", yyStart);
      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    traceFailure("NumFormulaLevel0$$Plus10", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.Spacing.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pSpacing(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyRepetition1;
    int        yyRepetition2;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("Spacing", yyStart);

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case ' ':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\t':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\f':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\r':
          {
            final int yyChoice2 = yyIndex;

            // Nested alternative 1.

            yyC = character(yyChoice2);
            if ('\n' == yyC) {
              yyIndex = yyChoice2 + 1;

              yyRepetition1 = yyIndex;
              continue;
            }

            // Nested alternative 2.

            yyRepetition1 = yyChoice2;
            continue;
          }

        case '\n':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '/':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;
              if ('/' == yyC) {

                yyRepetition2 = yyIndex;
                while (true) {

                  yyPredMatched = false;

                  yyPredResult = pEOL(yyRepetition2);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyC = character(yyRepetition2);
                    if (-1 != yyC) {
                      yyIndex = yyRepetition2 + 1;

                      yyRepetition2 = yyIndex;
                      continue;
                    }
                  } else {
                    yyError = yyError.select("spacing expected", yyStart);
                  }
                  break;
                }

                final int yyChoice2 = yyRepetition2;

                // Nested alternative 1.

                yyC = character(yyChoice2);
                if (-1 != yyC) {
                  yyIndex = yyChoice2 + 1;

                  switch (yyC) {
                  case '\r':
                    {
                      final int yyChoice3 = yyIndex;

                      // Nested alternative 1.

                      yyC = character(yyChoice3);
                      if ('\n' == yyC) {
                        yyIndex = yyChoice3 + 1;

                        yyRepetition1 = yyIndex;
                        continue;
                      }

                      // Nested alternative 2.

                      yyRepetition1 = yyChoice3;
                      continue;
                    }

                  case '\n':
                    {
                      yyRepetition1 = yyIndex;
                      continue;
                    }

                  default:
                    /* No match. */
                  }
                }

                // Nested alternative 2.

                yyPredMatched = false;

                yyC = character(yyChoice2);
                if (-1 != yyC) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyRepetition1 = yyChoice2;
                  continue;
                } else {
                  yyError = yyError.select("spacing expected", yyStart);
                }
              }
            }
          }
          break;

        default:
          /* No match. */
        }
      }

      // Nested alternative 2.

      yyResult = pMLComment(yyChoice1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    traceSuccess("Spacing", yyStart);
    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.Space.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pSpace(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("Space", yyStart);

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case ' ':
        {
          yyValue = null;

          traceSuccess("Space", yyStart);
          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\t':
        {
          yyValue = null;

          traceSuccess("Space", yyStart);
          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\f':
        {
          yyValue = null;

          traceSuccess("Space", yyStart);
          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\r':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if ('\n' == yyC) {
            yyIndex = yyChoice1 + 1;

            yyValue = null;

            traceSuccess("Space", yyStart);
            return new SemanticValue(yyValue, yyIndex, yyError);
          }

          // Nested alternative 2.

          yyValue = null;

          traceSuccess("Space", yyStart);
          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '\n':
        {
          yyValue = null;

          traceSuccess("Space", yyStart);
          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    traceFailure("Space", yyStart);
    yyError = yyError.select("space expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.EOL.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pEOL(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("EOL", yyStart);

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\r':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if ('\n' == yyC) {
            yyIndex = yyChoice1 + 1;

            yyValue = null;

            traceSuccess("EOL", yyStart);
            return new SemanticValue(yyValue, yyIndex, yyError);
          }

          // Nested alternative 2.

          yyValue = null;

          traceSuccess("EOL", yyStart);
          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '\n':
        {
          yyValue = null;

          traceSuccess("EOL", yyStart);
          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    traceFailure("EOL", yyStart);
    yyError = yyError.select("EOL expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.Comment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pComment(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("Comment", yyStart);

    // Alternative 1.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('/' == yyC) {
        yyIndex = yyIndex + 1;

        yyRepetition1 = yyIndex;
        while (true) {

          yyPredMatched = false;

          yyPredResult = pEOL(yyRepetition1);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyC = character(yyRepetition1);
            if (-1 != yyC) {
              yyIndex = yyRepetition1 + 1;

              yyRepetition1 = yyIndex;
              continue;
            }
          } else {
            yyError = yyError.select("comment expected", yyStart);
          }
          break;
        }

        final int yyChoice1 = yyRepetition1;

        // Nested alternative 1.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case '\r':
            {
              final int yyChoice2 = yyIndex;

              // Nested alternative 1.

              yyC = character(yyChoice2);
              if ('\n' == yyC) {
                yyIndex = yyChoice2 + 1;

                yyValue = null;

                traceSuccess("Comment", yyStart);
                return new SemanticValue(yyValue, yyIndex, yyError);
              }

              // Nested alternative 2.

              yyValue = null;

              traceSuccess("Comment", yyStart);
              return new SemanticValue(yyValue, yyChoice2, yyError);
            }

          case '\n':
            {
              yyValue = null;

              traceSuccess("Comment", yyStart);
              return new SemanticValue(yyValue, yyIndex, yyError);
            }

          default:
            /* No match. */
          }
        }

        // Nested alternative 2.

        yyPredMatched = false;

        yyC = character(yyChoice1);
        if (-1 != yyC) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          traceSuccess("Comment", yyStart);
          return new SemanticValue(yyValue, yyChoice1, yyError);
        } else {
          yyError = yyError.select("comment expected", yyStart);
        }
      }
    }

    // Alternative 2.

    yyResult = pMLComment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      traceSuccess("Comment", yyStart);
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    traceFailure("Comment", yyStart);
    yyError = yyError.select("comment expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.SLComment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pSLComment(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("SLComment", yyStart);

    // Alternative 1.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('/' == yyC) {
        yyIndex = yyIndex + 1;

        yyRepetition1 = yyIndex;
        while (true) {

          yyPredMatched = false;

          yyPredResult = pEOL(yyRepetition1);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyC = character(yyRepetition1);
            if (-1 != yyC) {
              yyIndex = yyRepetition1 + 1;

              yyRepetition1 = yyIndex;
              continue;
            }
          } else {
            yyError = yyError.select("s l comment expected", yyStart);
          }
          break;
        }

        final int yyChoice1 = yyRepetition1;

        // Nested alternative 1.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case '\r':
            {
              final int yyChoice2 = yyIndex;

              // Nested alternative 1.

              yyC = character(yyChoice2);
              if ('\n' == yyC) {
                yyIndex = yyChoice2 + 1;

                yyValue = null;

                traceSuccess("SLComment", yyStart);
                return new SemanticValue(yyValue, yyIndex, yyError);
              }

              // Nested alternative 2.

              yyValue = null;

              traceSuccess("SLComment", yyStart);
              return new SemanticValue(yyValue, yyChoice2, yyError);
            }

          case '\n':
            {
              yyValue = null;

              traceSuccess("SLComment", yyStart);
              return new SemanticValue(yyValue, yyIndex, yyError);
            }

          default:
            /* No match. */
          }
        }

        // Nested alternative 2.

        yyPredMatched = false;

        yyC = character(yyChoice1);
        if (-1 != yyC) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          traceSuccess("SLComment", yyStart);
          return new SemanticValue(yyValue, yyChoice1, yyError);
        } else {
          yyError = yyError.select("s l comment expected", yyStart);
        }
      }
    }

    // Done.
    traceFailure("SLComment", yyStart);
    yyError = yyError.select("s l comment expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.MLComment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pMLComment(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyPredIndex;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("MLComment", yyStart);

    // Alternative 1.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;

        yyRepetition1 = yyIndex;
        while (true) {

          final int yyChoice1 = yyRepetition1;

          // Nested alternative 1.

          yyResult = pMLComment(yyChoice1);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {

            yyRepetition1 = yyResult.index;
            continue;
          }

          // Nested alternative 2.

          yyPredMatched = false;

          yyC = character(yyChoice1);
          if ('*' == yyC) {
            yyPredIndex = yyChoice1 + 1;

            yyC = character(yyPredIndex);
            if ('/' == yyC) {

              yyPredMatched = true;
            }
          }

          if (! yyPredMatched) {

            yyC = character(yyChoice1);
            if (-1 != yyC) {
              yyIndex = yyChoice1 + 1;

              yyRepetition1 = yyIndex;
              continue;
            }
          } else {
            yyError = yyError.select("m l comment expected", yyStart);
          }
          break;
        }

        yyBase = yyRepetition1;
        yyC    = character(yyBase);
        if ('*' == yyC) {
          yyIndex = yyRepetition1 + 1;

          yyC = character(yyIndex);
          if ('/' == yyC) {
            yyIndex = yyIndex + 1;

            yyValue = null;

            traceSuccess("MLComment", yyStart);
            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("'*/' expected", yyBase);
          }
        } else {
          yyError = yyError.select("'*/' expected", yyBase);
        }
      }
    }

    // Done.
    traceFailure("MLComment", yyStart);
    yyError = yyError.select("m l comment expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.Identifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pIdentifier(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("Identifier", yyStart);

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (! contains (KEYWORDS, yyValue)) {

        traceSuccess("Identifier", yyStart);
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    traceFailure("Identifier", yyStart);
    yyError = yyError.select("identifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.Word.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pWord(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("Word", yyStart);

    // Alternative 1.

    yyResult = pWordCharacters(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        traceSuccess("Word", yyStart);
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    traceFailure("Word", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.WordCharacters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pWordCharacters(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("WordCharacters", yyStart);

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char h = (char)yyC;

      if (Character.isJavaIdentifierStart (h)) {

        yyRepetition1 = yyIndex;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;
            char t = (char)yyC;

            if (Character.isJavaIdentifierPart (t)) {

              yyRepetition1 = yyIndex;
              continue;
            }
          }
          break;
        }

        yyValue = difference(yyStart, yyRepetition1);

        traceSuccess("WordCharacters", yyStart);
        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    traceFailure("WordCharacters", yyStart);
    yyError = yyError.select("word characters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal syntax.ExpParser.EOF.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pEOF(final int yyStart) throws IOException {
    int        yyC;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    traceEnter("EOF", yyStart);

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if (-1 != yyC) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyValue = null;

      traceSuccess("EOF", yyStart);
      return new SemanticValue(yyValue, yyStart, yyError);
    } else {
      yyError = yyError.select("EOF expected", yyStart);
    }

    // Done.
    traceFailure("EOF", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
  * Drop the current path off string when it occurs at the beginning.
  */
  public String dropCurrentPath (String string) {
    int index = 0;
    int stringlen = string.length ();
    String prefix = System.getProperty ("user.dir");
    int prefixlen = prefix.length ();
    while ((index < stringlen) && (index < prefixlen) && (string.charAt (index) == prefix.charAt (index))) {
      index++;
    }
    if ((index != 0) && (string.charAt (index) == java.io.File.separatorChar)) {
      index++;
    }
    return string.substring (index);
  }
  
  /**
  * Format a Rats! parser error message according to Scala compiler
  * conventions for better compatibility with error processors.
  */
  public String formatParseError (ParseError error, Boolean showCoord) throws IOException {
    StringBuilder buf = new StringBuilder ();
    
    if (error.index == -1) {
      buf.append (error.msg);
    } else {
      Location loc = location (error.index);
      if (showCoord) {
        String filename = loc.file;
        buf.append (filename);
        buf.append (':');
        buf.append (loc.line);
        buf.append (": ");
      }
      
      buf.append (error.msg);
      buf.append ("\n");
      
      String line = lineAt (error.index);
      buf.append (line);
      buf.append ('\n');
      for (int i = 1; i < loc.column; i++) buf.append (' ');
      buf.append ("^");
    }
    
    return buf.toString ();
  }
  
  static {
    add (KEYWORDS, new String[] { "false", "true" });
  }

  // =========================================================================

  /**
   * Add the specified values to the specified set.
   *
   * @param set The set.
   * @param values The new values.
   */
  protected static final <T> void add(Set<T> set, T[] values) {
    for (T v : values) set.add(v);
  }

  /**
   * Check whether the specified set contains the specified value.
   *
   * @param set The set.
   * @param value The value.
   * @return <code>true</code> if the set contains the value.
   */
  protected static final <T> boolean contains(Set<T> set, T value) {
    return set.contains(value);
  }

  // =========================================================================

  /**
   * Trace entering the specified production.
   *
   * @param name The name.
   * @param index The index.
   */
  protected void traceEnter(String name, int index) {
    if (! DEBUG) return;

    yyOut.p("enter ").p(name).p(" @ ").p(index);
    if (PEEK) yyOut.p(" : \"").escape(peek(index)).p('\"');
    yyOut.pln().flush();
  }

  /**
   * Trace a successful exit from the specified production.
   *
   * @param name The name.
   * @param index The index.
   */
  protected void traceSuccess(String name, int index) {
    if (! DEBUG) return;
    yyOut.p("exit ").p(name).p(" @ ").p(index).pln(" with match").flush();
  }

  /**
   * Trace a failed exit from the specified production.
   *
   * @param name The name.
   * @param index The index.
   */
  protected void traceFailure(String name, int index) {
    if (! DEBUG) return;
    yyOut.p("exit ").p(name).p(" @ ").p(index).pln(" with error").flush();
  }

  /**
   * Trace a lookup in the memoization table for the specified production.
   *
   * @param name The name.
   * @param index The index.
   * @param result The result.
   */
  protected void traceLookup(String name, int index, Result result) {
    if (! DEBUG) return;

    yyOut.p("lookup ").p(name).p(" @ ").p(index);
    if (PEEK) yyOut.p(" : \"").escape(peek(index)).p('\"');
    yyOut.p(" -> ");
    if (result.hasValue()) {
      yyOut.p("match");
    } else {
      yyOut.p("error");
    }
    yyOut.pln().flush();
  }

}
